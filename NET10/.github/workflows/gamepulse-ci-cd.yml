name: GamePulse CI/CD Pipeline

# 워크플로우 트리거 조건
on:
  push:
    branches: [ main, develop ]
    paths:
      - 'GamePulse/**'
      - '.github/workflows/gamepulse-ci-cd.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'GamePulse/**'
  release:
    types: [ published ]
  workflow_dispatch:
    inputs:
      version:
        description: '배포할 버전 (예: 1.2.3)'
        required: false
        type: string
      environment:
        description: '배포 환경'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: '강제 배포 (기존 태그 덮어쓰기)'
        required: false
        default: false
        type: boolean

# 환경 변수
env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: gamepulse
  ECS_SERVICE: gamepulse-service
  ECS_CLUSTER: gamepulse-cluster
  DOTNET_VERSION: '9.0.x'

# 작업 정의
jobs:
  # ============================================================================
  # 1. 코드 품질 검사 및 테스트
  # ============================================================================
  test:
    name: 테스트 및 코드 품질 검사
    runs-on: ubuntu-latest
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # 전체 히스토리 가져오기 (버전 태깅용)

    - name: .NET 설정
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: 의존성 복원
      run: |
        cd GamePulse
        dotnet restore

    - name: 빌드
      run: |
        cd GamePulse
        dotnet build --configuration Release --no-restore

    - name: 단위 테스트 실행
      run: |
        cd GamePulse.Test
        dotnet test --configuration Release --no-build --verbosity normal \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults

    - name: 코드 커버리지 업로드
      uses: codecov/codecov-action@v3
      with:
        directory: ./GamePulse.Test/TestResults
        flags: unittests
        name: gamepulse-coverage

    - name: 보안 스캔 (CodeQL)
      uses: github/codeql-action/init@v3
      with:
        languages: csharp

    - name: CodeQL 분석 실행
      uses: github/codeql-action/analyze@v3

  # ============================================================================
  # 2. Docker 이미지 빌드 및 ECR 푸시
  # ============================================================================
  build-and-push:
    name: Docker 빌드 및 ECR 푸시
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name != 'pull_request'
    
    outputs:
      image-tag: ${{ steps.version.outputs.version }}
      image-uri: ${{ steps.push.outputs.image-uri }}
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: AWS 자격 증명 설정
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Docker Buildx 설정
      uses: docker/setup-buildx-action@v3

    - name: 버전 결정
      id: version
      run: |
        cd GamePulse
        
        if [[ "${{ github.event_name }}" == "release" ]]; then
          # 릴리즈 이벤트인 경우 태그에서 버전 추출
          VERSION="${{ github.event.release.tag_name }}"
          VERSION=${VERSION#v}  # v 접두사 제거
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
          # 수동 실행에서 버전이 지정된 경우
          VERSION="${{ github.event.inputs.version }}"
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          # main 브랜치인 경우 minor 버전 증가
          CURRENT_VERSION=$(cat version.txt 2>/dev/null || echo "1.0.0")
          VERSION=$(./scripts/push-to-ecr.sh --dry-run --increment minor 2>/dev/null | grep "자동 증가된 버전" | cut -d' ' -f4 | cut -d'(' -f1)
        else
          # develop 브랜치인 경우 patch 버전 증가 + 브랜치명
          CURRENT_VERSION=$(cat version.txt 2>/dev/null || echo "1.0.0")
          PATCH_VERSION=$(./scripts/push-to-ecr.sh --dry-run --increment patch 2>/dev/null | grep "자동 증가된 버전" | cut -d' ' -f4 | cut -d'(' -f1)
          BRANCH_NAME=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9]/-/g')
          VERSION="${PATCH_VERSION}-${BRANCH_NAME}.${GITHUB_RUN_NUMBER}"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "결정된 버전: $VERSION"

    - name: ECR 로그인
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Docker 이미지 빌드 및 푸시
      id: push
      run: |
        cd GamePulse
        
        # ECR URI 구성
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:${{ steps.version.outputs.version }}
        
        # 빌드 및 푸시 옵션 설정
        PUSH_OPTIONS="--version ${{ steps.version.outputs.version }}"
        
        if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.event_name }}" == "release" ]]; then
          PUSH_OPTIONS="$PUSH_OPTIONS --latest"
        fi
        
        if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
          PUSH_OPTIONS="$PUSH_OPTIONS --force"
        fi
        
        # 멀티 아키텍처 빌드 (프로덕션 환경)
        if [[ "${{ github.event.inputs.environment }}" == "production" || "${{ github.event_name }}" == "release" ]]; then
          PUSH_OPTIONS="$PUSH_OPTIONS --multi-arch --platform linux/amd64,linux/arm64"
        fi
        
        # ECR 푸시 실행
        ./scripts/push-to-ecr.sh $PUSH_OPTIONS --scan
        
        echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "빌드된 이미지: $IMAGE_URI"

    - name: 이미지 취약점 스캔 결과 확인
      run: |
        # ECR 스캔 결과 대기 및 확인
        sleep 30
        
        aws ecr describe-image-scan-findings \
          --repository-name $ECR_REPOSITORY \
          --image-id imageTag=${{ steps.version.outputs.version }} \
          --region $AWS_REGION || echo "스캔 결과를 아직 사용할 수 없습니다."

  # ============================================================================
  # 3. 스테이징 환경 배포
  # ============================================================================
  deploy-staging:
    name: 스테이징 환경 배포
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4

    - name: AWS 자격 증명 설정
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ECS 태스크 정의 업데이트
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: terraform/gamepulse-aws/ecs-task-definition-staging.json
        container-name: gamepulse-app
        image: ${{ needs.build-and-push.outputs.image-uri }}

    - name: ECS 서비스 배포
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}-staging
        cluster: ${{ env.ECS_CLUSTER }}-staging
        wait-for-service-stability: true

    - name: 배포 상태 확인
      run: |
        echo "스테이징 배포 완료"
        echo "이미지: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "서비스: ${{ env.ECS_SERVICE }}-staging"
        echo "클러스터: ${{ env.ECS_CLUSTER }}-staging"

  # ============================================================================
  # 4. 프로덕션 환경 배포
  # ============================================================================
  deploy-production:
    name: 프로덕션 환경 배포
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: production
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4

    - name: AWS 자격 증명 설정
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: 프로덕션 배포 승인 대기
      uses: trstringer/manual-approval@v1
      if: github.event_name != 'release'
      with:
        secret: ${{ github.TOKEN }}
        approvers: ${{ secrets.PRODUCTION_APPROVERS }}
        minimum-approvals: 2
        issue-title: "프로덕션 배포 승인 요청"
        issue-body: |
          프로덕션 환경에 다음 이미지를 배포하려고 합니다:
          
          **이미지**: ${{ needs.build-and-push.outputs.image-uri }}
          **버전**: ${{ needs.build-and-push.outputs.image-tag }}
          **브랜치**: ${{ github.ref_name }}
          **커밋**: ${{ github.sha }}
          
          배포를 승인하려면 이 이슈에 "approve"라고 댓글을 달아주세요.

    - name: ECS 태스크 정의 업데이트
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: terraform/gamepulse-aws/ecs-task-definition-production.json
        container-name: gamepulse-app
        image: ${{ needs.build-and-push.outputs.image-uri }}

    - name: ECS 서비스 배포 (Blue/Green)
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
        codedeploy-appspec: terraform/gamepulse-aws/appspec.yml
        codedeploy-application: gamepulse-app
        codedeploy-deployment-group: gamepulse-dg

    - name: 배포 후 헬스 체크
      run: |
        # ALB 엔드포인트에서 헬스 체크
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names gamepulse-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "헬스 체크 시작: https://$ALB_DNS/health"
        
        for i in {1..30}; do
          if curl -f -s "https://$ALB_DNS/health" > /dev/null; then
            echo "헬스 체크 성공 (시도 $i/30)"
            break
          else
            echo "헬스 체크 실패 (시도 $i/30), 30초 후 재시도..."
            sleep 30
          fi
        done

    - name: 배포 완료 알림
      run: |
        echo "프로덕션 배포 완료"
        echo "이미지: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "버전: ${{ needs.build-and-push.outputs.image-tag }}"
        echo "서비스: ${{ env.ECS_SERVICE }}"
        echo "클러스터: ${{ env.ECS_CLUSTER }}"

  # ============================================================================
  # 5. 배포 후 통합 테스트
  # ============================================================================
  integration-test:
    name: 통합 테스트
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'success'
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4

    - name: Node.js 설정 (k6 테스트용)
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: k6 설치
      run: |
        sudo gpg -k
        sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6

    - name: 스테이징 환경 부하 테스트
      run: |
        cd GamePulse/k6
        
        # 스테이징 ALB 엔드포인트 가져오기
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names gamepulse-alb-staging \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        # k6 부하 테스트 실행
        K6_TARGET_URL="https://$ALB_DNS" k6 run load-test.js

    - name: 테스트 결과 업로드
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: integration-test-results
        path: GamePulse/k6/results/

  # ============================================================================
  # 6. 정리 작업
  # ============================================================================
  cleanup:
    name: 정리 작업
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: 오래된 ECR 이미지 정리
      run: |
        aws ecr list-images \
          --repository-name $ECR_REPOSITORY \
          --filter tagStatus=UNTAGGED \
          --query 'imageIds[?imageDigest!=null]' \
          --output json | \
        jq '.[] | select(.imagePushedAt < (now - 86400 * 7))' | \
        aws ecr batch-delete-image \
          --repository-name $ECR_REPOSITORY \
          --image-ids file:///dev/stdin || echo "정리할 이미지가 없습니다."

    - name: 워크플로우 실행 결과 요약
      run: |
        echo "=== CI/CD 파이프라인 실행 결과 ==="
        echo "빌드 상태: ${{ needs.build-and-push.result }}"
        echo "스테이징 배포: ${{ needs.deploy-staging.result }}"
        echo "프로덕션 배포: ${{ needs.deploy-production.result }}"
        echo "이미지 태그: ${{ needs.build-and-push.outputs.image-tag }}"
        echo "실행 시간: $(date)"